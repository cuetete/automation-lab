#include "DSP2833x_Device.h"     // DSP2833x Headerfile Include File
#include "DSP2833x_Examples.h"   // DSP2833x Examples Include File
//#include "W5500.h" 
// Prototype statements for functions found within this file.
Uint16 SCIBOK=0;
Uint16 RS485OK=0;
Uint16 SEGADOK=0;
Uint16 DACOK=0;
Uint16 RTCLCDOK=0;
Uint16 EEROK=0;
Uint16 BUZZOK=0;
Uint16 PWMOK=0;
Uint16 CANOK=0;
Uint16 KEYINTOK=0;
Uint16 DCMOK=0;
Uint16 STPMOK=0;
Uint16 AUDOK=0;
Uint16 NETOK=0;
// Global counts used in this example
extern void delay(Uint16 time);
//--------------------------------------------------------------------------------------------------------SCI A&B
// Test 1,SCIA  DLB, 8-bit word, baud rate 0x000F, default, 1 STOP bit, no parity
void scia_echoback_init()
{
    // Note: Clocks were turned on to the SCIA peripheral
    // in the InitSysCtrl() function

 	SciaRegs.SCICCR.all =0x0007;   // 1 stop bit,  No loopback
                                   // No parity,8 char bits,
                                   // async mode, idle-line protocol
	SciaRegs.SCICTL1.all =0x0003;  // enable TX, RX, internal SCICLK,
                                   // Disable RX ERR, SLEEP, TXWAKE
	SciaRegs.SCICTL2.all =0x0003;
	SciaRegs.SCICTL2.bit.TXINTENA =1;
	SciaRegs.SCICTL2.bit.RXBKINTENA =1;
	#if (CPU_FRQ_150MHZ)
	      SciaRegs.SCIHBAUD    =0x0001;  // 9600 baud @LSPCLK = 37.5MHz.
	      SciaRegs.SCILBAUD    =0x00E7;
	#endif
	#if (CPU_FRQ_100MHZ)
      SciaRegs.SCIHBAUD    =0x0001;  // 9600 baud @LSPCLK = 20MHz.
      SciaRegs.SCILBAUD    =0x0044;
	#endif
	SciaRegs.SCICTL1.all =0x0023;  // Relinquish SCI from Reset
}

// Transmit a character from the SCI
void scia_xmit(int a)
{
    while (SciaRegs.SCIFFTX.bit.TXFFST != 0) {}
    SciaRegs.SCITXBUF=a;

}

void scia_msg(char * msg)
{
    int i;
    i = 0;
    while(msg[i] != '\0')
    {
        scia_xmit(msg[i]);
        i++;
    }
}

// Initalize the SCI FIFO
void scia_fifo_init()
{
    SciaRegs.SCIFFTX.all=0xE040;
    SciaRegs.SCIFFRX.all=0x204f;
    SciaRegs.SCIFFCT.all=0x0;

}
// Test 1,SCIA  DLB, 8-bit word, baud rate 0x000F, default, 1 STOP bit, no parity
void scib_echoback_init()
{
    // Note: Clocks were turned on to the Scib peripheral
    // in the InitSysCtrl() function

 	ScibRegs.SCICCR.all =0x0007;   // 1 stop bit,  No loopback
                                   // No parity,8 char bits,
                                   // async mode, idle-line protocol
	ScibRegs.SCICTL1.all =0x0003;  // enable TX, RX, internal SCICLK,
                                   // Disable RX ERR, SLEEP, TXWAKE
	ScibRegs.SCICTL2.all =0x0003;
	ScibRegs.SCICTL2.bit.TXINTENA =1;
	ScibRegs.SCICTL2.bit.RXBKINTENA =1;
	#if (CPU_FRQ_150MHZ)
	      ScibRegs.SCIHBAUD    =0x0001;  // 9600 baud @LSPCLK = 37.5MHz.
	      ScibRegs.SCILBAUD    =0x00E7;
	#endif
	#if (CPU_FRQ_100MHZ)
      ScibRegs.SCIHBAUD    =0x0001;  // 9600 baud @LSPCLK = 20MHz.
      ScibRegs.SCILBAUD    =0x0044;
	#endif
	ScibRegs.SCICTL1.all =0x0023;  // Relinquish SCI from Reset
}

// Transmit a character from the SCI
void scib_xmit(int a)
{
    while (ScibRegs.SCIFFTX.bit.TXFFST != 0) {}
    ScibRegs.SCITXBUF=a;

}

void scib_msg(char * msg)
{
    int i;
    i = 0;
    while(msg[i] != '\0')
    {
        scib_xmit(msg[i]);
        i++;
    }
}

// Initalize the SCI FIFO
void scib_fifo_init()
{
    ScibRegs.SCIFFTX.all=0xE040;
    ScibRegs.SCIFFRX.all=0x204f;
    ScibRegs.SCIFFCT.all=0x0;

}
//--------------------------------------------------------------------------------------------------------RS485
#define InitDIR()                                          \
                     EALLOW;                               \
                     GpioCtrlRegs.GPBPUD.bit.GPIO61 = 0;   \
                     GpioCtrlRegs.GPBDIR.bit.GPIO61 = 1;   \
                     GpioDataRegs.GPBCLEAR.bit.GPIO61 = 1; \
                     EDIS;                                 					 
#define RX_EN       GpioDataRegs.GPBCLEAR.bit.GPIO61 = 1;
#define TX_EN       GpioDataRegs.GPBSET.bit.GPIO61 = 1;

void scic_echoback_init()
{
    ScicRegs.SCICTL1.bit.SWRESET =0;
 	ScicRegs.SCICCR.all =0x0007;   // 1 stop bit,  No loopback
                                   // No parity,8 char bits,
                                   // async mode, idle-line protocol
	ScicRegs.SCICTL1.all =0x0003;  // enable TX, RX, internal SCICLK,
                                   // Disable RX ERR, SLEEP, TXWAKE
	#if (CPU_FRQ_150MHZ)
	      ScicRegs.SCIHBAUD    =0x0001;  // 9600 baud @LSPCLK = 37.5MHz.
	      ScicRegs.SCILBAUD    =0x00E7;
	#endif
	#if (CPU_FRQ_100MHZ)
      ScicRegs.SCIHBAUD    =0x0001;  // 9600 baud @LSPCLK = 20MHz.
      ScicRegs.SCILBAUD    =0x0044;
	#endif
	ScicRegs.SCICTL1.all =0x0023;  // Relinquish SCI from Reset
}


// Transmit a character from the SCI
void scic_xmit(int a)
{
    while (ScicRegs.SCICTL2.bit.TXRDY == 0) {}
    ScicRegs.SCITXBUF=a;

}

void scic_msg(char * msg)
{
    int i;
    i = 0;
	TX_EN;
    while(msg[i] != '\0')
    {
        scic_xmit(msg[i]);
        i++;
    }
	RX_EN;
}
//--------------------------------------------------------------------------------------------------------SEG&AD
void s_delay(void)
{
    long      i;
    for (i = 0; i < 45000; i++) {} //
}

void loopdelay()
{
    long      i;
    for (i = 0; i < 4500000; i++) {} 
}

void spi_init()
{    
	SpiaRegs.SPICCR.all =0x004F;// SPI软件复位, 极性位为1（下降沿发送数据）, 每次移
	                            //进和移出16位字长度；禁止SPI内部回送（LOOKBACK）功能；
	SpiaRegs.SPICTL.all =0x0006; // 使能主机模式，正常相位，使能主机发送，禁止接收
	                            //溢出中断，禁止SPI中断；
                                   
	SpiaRegs.SPIBRR =0x007F;	//SPI波特率=25M/128	=195.3KHZ；							
    SpiaRegs.SPICCR.all =0x00CF;//停止SPI软件复位准备接收或发送；禁止回送模式； 
    SpiaRegs.SPIPRI.bit.FREE = 1;  // 自由运行     
}
void spi_xmit(Uint16 a)
{
    SpiaRegs.SPITXBUF=a;
}    

void spi_fifo_init()										
{
    SpiaRegs.SPIFFTX.all=0xE040;//使能FIFO;清除发送中断标志位；禁止FIFO发送中断；
                                //发送中断级别定义为0；
    SpiaRegs.SPIFFRX.all=0x204f;//清除FF溢出标志位；清除溢出接受中断标志位；禁止
	                            //FF接受中断；接受中断级别为16；
    SpiaRegs.SPIFFCT.all=0x0;//SPITXBUF到移位寄存器传送不延迟；
}  

#define ADC_MODCLK 0x5   // HSPCLK = SYSCLKOUT/2*ADC_MODCLK2 = 150/(2*4)             = 15MHz
                         //    for 60 MHz devices:    HSPCLK =  60/(2*4)             = 7.5 MHz
#define ADC_CKPS   0x1   // ADC module clock = HSPCLK/2*ADC_CKPS   = 15MHz/(1*2)   = 7.5MHz
                         
#define ADC_SHCLK  0xf   // S/H width in ADC module periods                          = 16 ADC clocks
#define AVG        100  // Average sample limit
#define ZOFFSET    0x00  // Average Zero offset
#define BUF_SIZE   256  // Sample buffer size

Uint16 SampleTable[BUF_SIZE];

void InitSegCS(void)
{                                         
	EALLOW;                               
	GpioCtrlRegs.GPBPUD.bit.GPIO60 = 0;   
	GpioCtrlRegs.GPBDIR.bit.GPIO60 = 1;   
	GpioDataRegs.GPBCLEAR.bit.GPIO60 = 1; 
	EDIS; 
}

//------------------------------------------------------------------------------------
Uint16 SegData[16]=		//"0"~"F" code of common anode 7-SegmentLED
{
	0xC0,		//0
	0xF9,		//1
	0xA4,		//2
	0xB0,		//3
	0x99,		//4
	0x92,		//5
	0x82,		//6
	0xF8,		//7
	0x80,		//8
	0x90,		//9
	0x88,		//A
	0x83,		//B
	0xC6,		//C
	0xA1,		//E
	0x86,		//E
	0x8E		//F
};

void ShowChar(Uint16 s1, Uint16 s2, Uint16 s3, Uint16 s4)
{                                         
	Uint16 sdata=0;
	sdata=SegData[s1];
	sdata &=0x007F;
	sdata <<=8;
	sdata |=SegData[s2];
	spi_xmit(sdata);
	
	sdata=SegData[s3];
	sdata <<=8;
	sdata |=SegData[s4];
	spi_xmit(sdata);
	
	GpioDataRegs.GPBCLEAR.bit.GPIO60 = 1;
	s_delay();
	GpioDataRegs.GPBSET.bit.GPIO60 = 1;
}

//--------------------------------------------------------------------------------------------------------DAC
#define SetLOAD GpioDataRegs.GPBDAT.bit.GPIO49=1;	//将LOAD置高
#define ClrLOAD GpioDataRegs.GPBDAT.bit.GPIO49=0;	//将LOAD置低

/*void delay(unsigned int t)
{
 
 	while(t>0)
    	t--;
}*/

void WriteDAC(unsigned char add,unsigned char rng,unsigned char vol)
{   
	unsigned short int data;
    data=0x0000;
    ///大家要知道这里所定义的各个变量的含义,add是4个通道的地址（00，01，10，11）
    ///                                     RNG是输出范围的倍数，可以是0或1。
    ///                                     VOL是0~256数据
    
     data = ((add<<14) | (rng<<13) | (vol<<5));
     //注意这里的有效数据是11位，SPI初始化中也进行了定义
 
    while(SpiaRegs.SPISTS.bit.BUFFULL_FLAG ==1);			//判断SPI的发送缓冲区是否是空的,等于0可写数据
     
       SpiaRegs.SPITXBUF = data;	//把发送的数据写如SPI发送缓冲区

    while( SpiaRegs.SPISTS.bit.BUFFULL_FLAG==1);		//当发送缓冲区出现满标志位时,开始琐存数据
    	 
	delay(1500);//同通过一负跳变琐存要发送的数据,看TLV5620数据手册即可得知
    ClrLOAD;
    
	delay(150);
    SetLOAD;
    
    delay(1500);	
}
//--------------------------------------------------------------------------------------------------------RTC&LCD
#define uchar unsigned char
#define LCD_RS GpioDataRegs.GPADAT.bit.GPIO0
#define LCD_EN GpioDataRegs.GPADAT.bit.GPIO1
#define LCD_DB GpioDataRegs.GPADAT.all
extern void Init8563(void);
extern void GetTime(void);
extern uchar TAB_T[];
void Init_Port(void)
{
	EALLOW;   
// 用户根据需要可以使能内部上拉或禁止. 
// 其他不需要的行注释掉；
    GpioCtrlRegs.GPAPUD.bit.GPIO0 = 0;    // 使能GPIO1 引脚内部上拉
    GpioCtrlRegs.GPAPUD.bit.GPIO1 = 1;   // 禁止GPIO1 引脚内部上拉
   
/* 通过I/O功能选择寄存器配置通用I/O功能*/
    GpioCtrlRegs.GPAMUX1.all = 0;   // 配置GPIO0-GPIO15为通用I/O口
	GpioCtrlRegs.GPAMUX2.bit.GPIO24 = 0;   // 配置GPIO24为通用I/O口

/* 设置I/O口为输入引脚*/
    GpioCtrlRegs.GPADIR.all = 0x10003FF;// 配置GPIO0-GPIO9  GPIO24为输出引脚
	
// 每个输入口可以有不同的输入限定
   // a) 输入与系统时钟 SYSCLKOUT同步
   // b) 输入被指定的采样窗口限定
   // c) 输入异步 (仅对外设输入有效)
   GpioCtrlRegs.GPAQSEL1.all = 0x0000;    // GPIO0-GPIO15与系统时钟SYSCLKOUT 同步
   GpioCtrlRegs.GPAQSEL2.bit.GPIO24 = 0x0000;    // GPIO24与系统时钟SYSCLKOUT 同步
//输出数据LCD_RS置1和LCD_EN清零  
   GpioDataRegs.GPADAT.bit.GPIO0 = 1;
   GpioDataRegs.GPADAT.bit.GPIO1 = 0;
   GpioDataRegs.GPADAT.bit.GPIO24 = 0;  //cs=0
   EDIS;
} 

/*-------------------------------------- 
;模块名称:LCD_write_command(); 
;功    能:LCD1602写指令函数 
;参数说明:command为写命令参数
;-------------------------------------*/ 
void LCD_write_command(uchar command)
{
LCD_RS=0;         //指令
LCD_EN=1;          //允许
LCD_DB=(command<<2)|0x0002;//赋值给D0-D7对应的GPIO4-GPIO11引脚
DELAY_US(10000); 
LCD_EN=0;
DELAY_US(100);

}

/*-------------------------------------- 
;模块名称:LCD_write_data(); 
;功    能:LCD1602写数据函数 
;占用资源: P2.0--RS(LCD_RS),P2.1--RW(LCD_RW),P2.2--E(LCD_E).
;参数说明:dat为写数据参数
;-------------------------------------*/
void LCD_write_data(uchar dat)
{
LCD_RS=1;         //指令
LCD_EN=1;          //允许
LCD_DB=(dat<<2)|0x0003;//赋值给D0-D7对应的GPIO4-GPIO11引脚
DELAY_US(10000); 
LCD_EN=0; 
DELAY_US(100);
}
/*-------------------------------------- 
;模块名称:LCD_init(); 
;功    能:初始化LCD1602 
;占用资源:--
;参数说明:--
;-------------------------------------*/ 
void LCD_init(void)
{
DELAY_US(100000);//延迟100ms
LCD_write_command(0x30);//功能设置
DELAY_US(200);//延迟200us
LCD_write_command(0x30);//功能设置
DELAY_US(200);//延迟200us
LCD_write_command(0x0c);//显示开关控制
DELAY_US(200);//延迟200us
LCD_write_command(0x01);//显示清除
DELAY_US(12000);//延迟12ms
LCD_write_command(0x06);//显示清除
DELAY_US(500);//延迟500us
}

//--------------------------------------------------------------------------------------------------------EEPROM
extern void Eerom_Gpio_Init(void);
extern void writebyte(Uint16 addr,Uint16 data);
extern Uint16 readbyte(Uint16 addr);
Uint16 RecvBuf[16]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
Uint16 TranBuf[16]={0,1,2,3,4,5,6,7,8,9,0xA,0xB,0xC,0xD,0xE,0xF};

//--------------------------------------------------------------------------------------------------------Buzz
#define BUZZ_CLK_GENER			GpioDataRegs.GPATOGGLE.bit.GPIO10 = 1;		//蜂鸣器控制IO，IO电平翻转，产生控制脉冲
#define DISABLE_TIMER1_INT		IER &= 0xFFFE;								//关闭定时器
#define ENABLE_TIMER1_INT		IER |= M_INT1;								//打开定时器
#define BUZZ_OFF				GpioDataRegs.GPASET.bit.GPIO10 = 1;			//关闭蜂鸣器

void Buzz_Gpio_Init(void)
{
	EALLOW;
    GpioCtrlRegs.GPAPUD.bit.GPIO10 = 0;   									// Enable pullup on GPIO35
    GpioDataRegs.GPASET.bit.GPIO10 = 1;  									 // Load output latch
    GpioCtrlRegs.GPAMUX1.bit.GPIO10 = 0;  									// GPIO10 = GPIO
    GpioCtrlRegs.GPADIR.bit.GPIO10 = 1;   									// GPIO10 = output
    EDIS;
}
Uint16 Musi[23]={		//单位 us，不同频率下，蜂鸣器发出不同音调的声音
				0,
				3816,	//L_do
				3496,	//L_re
				3215,	//L_mi
				2865,	//L_fa
				2551,	//L_so
				2272,	//L_la
				2024,	//L_xi
				1912,	//do
				1703,	//re
				1517,	//mi
				1432,	//fa
				1275,	//so
				1136,	//la
				1013,	//xi
				956,	//H_do
				851,	//H_re
				758,	//H_mi
				716,	//H_fa
				638,	//H_so
				568,	//H_la
				506,	//H_xi
				0xFF	//STOP
				};
Uint16 Song[]=	{5,5,6,5,8,7,5,5,6,5,8,7,5,5,5,10,8,7,6,11,10,8,9,8,22	};	//《祝你生日快乐》简谱			
Uint16 DT[]={2,2,5,4,6,8,2,2,5,6,6,9,4,2,5,4,6,12,2,2,5,6,8,12 };			//节拍

void Buzz_Delay(Uint16 t)														//延时函数
{
	Uint32 i=0;
	Uint32 gain = 200000;													//延时增益
	Uint32 base=0;								
	base=gain*t; 															
	for(i=0;i<=base;i++);
}

interrupt void cpu_timer0_isr(void)
{
	CpuTimer0.InterruptCount++;
	BUZZ_CLK_GENER; 
   	PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;
}

//--------------------------------------------------------------------------------------------------------PWM
void HRPWM1_Config(period)
{
// ePWM1 register configuration with HRPWM
// ePWM1A toggle low/high with MEP control on Rising edge

	EPwm1Regs.TBCTL.bit.PRDLD = TB_IMMEDIATE;	        // set Immediate load
	EPwm1Regs.TBPRD = period;		                    // PWM frequency = 1 / period
	EPwm1Regs.CMPA.half.CMPA = period / 2;              // set duty 50% initially
    EPwm1Regs.CMPA.half.CMPAHR = (1 << 8);              // initialize HRPWM extension
	EPwm1Regs.CMPB = period / 2;	                    // set duty 50% initially
	EPwm1Regs.TBPHS.all = 0;
	EPwm1Regs.TBCTR = 0;

	EPwm1Regs.TBCTL.bit.CTRMODE = TB_COUNT_UP;
	EPwm1Regs.TBCTL.bit.PHSEN = TB_DISABLE;		       // EPWM1 is the Master
	EPwm1Regs.TBCTL.bit.SYNCOSEL = TB_SYNC_DISABLE;
	EPwm1Regs.TBCTL.bit.HSPCLKDIV = TB_DIV1;
	EPwm1Regs.TBCTL.bit.CLKDIV = TB_DIV1;

	EPwm1Regs.CMPCTL.bit.LOADAMODE = CC_CTR_ZERO;
	EPwm1Regs.CMPCTL.bit.LOADBMODE = CC_CTR_ZERO;
	EPwm1Regs.CMPCTL.bit.SHDWAMODE = CC_SHADOW;
	EPwm1Regs.CMPCTL.bit.SHDWBMODE = CC_SHADOW;

	EPwm1Regs.AQCTLA.bit.ZRO = AQ_CLEAR;               // PWM toggle low/high
	EPwm1Regs.AQCTLA.bit.CAU = AQ_SET;
	EPwm1Regs.AQCTLB.bit.ZRO = AQ_SET;
	EPwm1Regs.AQCTLB.bit.CBU = AQ_CLEAR;

	EALLOW;
	EPwm1Regs.HRCNFG.all = 0x0;
	EPwm1Regs.HRCNFG.bit.EDGMODE = HR_REP;				//MEP control on Rising edge
	EPwm1Regs.HRCNFG.bit.CTLMODE = HR_CMP;
	EPwm1Regs.HRCNFG.bit.HRLOAD  = HR_CTR_ZERO;
	EDIS;
}
void HRPWM2_Config(period)
{
// ePWM2 register configuration with HRPWM
// ePWM2A toggle low/high with MEP control on Rising edge

	EPwm2Regs.TBCTL.bit.PRDLD = TB_IMMEDIATE;	        // set Immediate load
	EPwm2Regs.TBPRD = period;		                    // PWM frequency = 1 / period
	EPwm2Regs.CMPA.half.CMPA = period / 2;              // set duty 50% initially
    EPwm2Regs.CMPA.half.CMPAHR = (1 << 8);              // initialize HRPWM extension
	EPwm2Regs.CMPB = period / 2;	                    // set duty 50% initially
	EPwm2Regs.TBPHS.all = 0;
	EPwm2Regs.TBCTR = 0;

	EPwm2Regs.TBCTL.bit.CTRMODE = TB_COUNT_UP;
	EPwm2Regs.TBCTL.bit.PHSEN = TB_DISABLE;		         // ePWM2 is the Master
	EPwm2Regs.TBCTL.bit.SYNCOSEL = TB_SYNC_DISABLE;
	EPwm2Regs.TBCTL.bit.HSPCLKDIV = TB_DIV1;
	EPwm2Regs.TBCTL.bit.CLKDIV = TB_DIV1;

	EPwm2Regs.CMPCTL.bit.LOADAMODE = CC_CTR_ZERO;
	EPwm2Regs.CMPCTL.bit.LOADBMODE = CC_CTR_ZERO;
	EPwm2Regs.CMPCTL.bit.SHDWAMODE = CC_SHADOW;
	EPwm2Regs.CMPCTL.bit.SHDWBMODE = CC_SHADOW;

	EPwm2Regs.AQCTLA.bit.ZRO = AQ_CLEAR;                  // PWM toggle low/high
	EPwm2Regs.AQCTLA.bit.CAU = AQ_SET;
	EPwm2Regs.AQCTLB.bit.ZRO = AQ_SET;
	EPwm2Regs.AQCTLB.bit.CBU = AQ_CLEAR;

	EALLOW;
	EPwm2Regs.HRCNFG.all = 0x0;
	EPwm2Regs.HRCNFG.bit.EDGMODE = HR_REP;                //MEP control on Rising edge
	EPwm2Regs.HRCNFG.bit.CTLMODE = HR_CMP;
	EPwm2Regs.HRCNFG.bit.HRLOAD  = HR_CTR_ZERO;

	EDIS;

}

//--------------------------------------------------------------------------------------------------------CAN
Uint16  CANErCnt=0;

Uint32  TestMbox1 = 0;
Uint32  TestMbox2 = 0;
Uint32  TestMbox3 = 0;
struct ECAN_REGS ECanaShadow;

void mailbox_read(int16 MBXnbr)
{
   volatile struct MBOX *Mailbox;
   Mailbox = &ECanaMboxes.MBOX0 + MBXnbr;
   TestMbox1 = Mailbox->MDL.all; // = 0x9555AAAn (n is the MBX number)
   TestMbox2 = Mailbox->MDH.all; // = 0x89ABCDEF (a constant)
   TestMbox3 = Mailbox->MSGID.all;// = 0x9555AAAn (n is the MBX number)

} // MSGID of a rcv MBX is transmitted as the MDL data.


void mailbox_check(int32 T1, int32 T2, int32 T3)
{
    if((T1 != T3) || ( T2 != 0x89ABCDEF))
    {
       CANErCnt++;
    }
}

//--------------------------------------------------------------------------------------------------------KEY&EXTINT
volatile Uint32 Xint1Count; //发生外部中断1的次数；
volatile Uint32 Xint2Count; //发生外部中断2的次数；
volatile Uint32 Xint2Loop; //给外部中断2的for循环变量

#define keyon1 GpioDataRegs.GPADAT.bit.GPIO14
#define keyon2 GpioDataRegs.GPADAT.bit.GPIO15

interrupt void xint1_isr(void)
{
	Uint32 i;
	for(i=0;i<1000000;i++);    //键盘消抖动
	while(keyon1==0);
	GpioDataRegs.GPATOGGLE.all = 0x00000300;   // GPIO8-GPIO9输出电平取反
	Xint1Count++;
	PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;
}

interrupt void xint2_isr(void)
{
	Uint32 i;
	for(Xint2Loop=1;Xint2Loop<=8;Xint2Loop++)
	{
	  GpioDataRegs.GPATOGGLE.all = 0x00000300;   // GPIO8-GPIO9输出电平取反
      DELAY_US(100000);  //延时0.1s
    }

	Xint2Count++;
	for(i=0;i<1000000;i++);    //键盘消抖动
	while(keyon2==0);
	PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;
}

//--------------------------------------------------------------------------------------------------------DC MOTOR
#define EPWM1_TIMER_TBPRD  5000  // 周期值

void InitEPwm1Example()
{

  // 设置时间基准的时钟信号（TBCLK）
   EPwm1Regs.TBCTL.bit.CTRMODE = TB_COUNT_UP; // 递增计数模式
   EPwm1Regs.TBPRD = EPWM1_TIMER_TBPRD;       // 设置定时器周期
   EPwm1Regs.TBCTL.bit.PHSEN = TB_DISABLE;    // 禁止相位加载
   EPwm1Regs.TBPHS.half.TBPHS = 0x0000;       // 时基相位寄存器的值赋值0
   EPwm1Regs.TBCTR = 0x0000;                   // 时基计数器清零
   EPwm1Regs.TBCTL.bit.HSPCLKDIV = TB_DIV2;   // 设置时基时钟速率为系统时钟SYSCLKOUT/4=37.5MHZ;
   EPwm1Regs.TBCTL.bit.CLKDIV = TB_DIV2;//由时基时钟频率和时基周期可知PWM1频率=10KHZ；

   // 设置比较寄存器的阴影寄存器加载条件：时基计数到0
   EPwm1Regs.CMPCTL.bit.SHDWAMODE = CC_SHADOW;
   EPwm1Regs.CMPCTL.bit.SHDWBMODE = CC_SHADOW;
   EPwm1Regs.CMPCTL.bit.LOADAMODE = CC_CTR_ZERO;
   EPwm1Regs.CMPCTL.bit.LOADBMODE = CC_CTR_ZERO;


   // 设置比较寄存器的值
   EPwm1Regs.CMPA.half.CMPA = 1000;     // 设置比较寄存器A的值
   EPwm1Regs.CMPB = 1000;               // 设置比较寄存器B的值

   // 设置动作限定；首先默认为转动方向为正转，这时只有PWM1A输出占空比；
   EPwm1Regs.AQCTLA.bit.ZRO = AQ_SET;            // 计数到0时PWM1A输出高电平
   EPwm1Regs.AQCTLA.bit.CAU = AQ_CLEAR;          // 递增计数时，发生比较寄存器A匹配时清除PWM1A输出

   EPwm1Regs.AQCTLB.bit.ZRO = AQ_CLEAR;            // 计数到0时PWM1B输出低电平
   EPwm1Regs.AQCTLB.bit.CBU = AQ_CLEAR;          // 递增计数时，发生比较寄存器A匹配时清除PWM1B输出
   
   // 3次0匹配事件发生时产生一个中断请求；一次匹配是100us，一共300us产生一次中断；
   EPwm1Regs.ETSEL.bit.INTSEL = ET_CTR_ZERO;     // 选择0匹配事件中断
   EPwm1Regs.ETSEL.bit.INTEN = 1;                // 使能事件触发中断
   EPwm1Regs.ETPS.bit.INTPRD = ET_3RD;           // 3次事件产生中断请求  
}

interrupt void epwm1_isr(void)
{
   EPwm1Regs.ETCLR.bit.INT = 1;

   // 清除PIE应答寄存器的第三位，以响应组3内的其他中断请求；
   PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;
}

//--------------------------------------------------------------------------------------------------------STP MOTOR
unsigned char Step_table[]={0x0004,0x0008,0x0010,0x0020};
unsigned char Step_table1[]={0x0020,0x0010,0x0008,0x0004};
void Gpio_select(void)
{

   
    EALLOW;
	GpioCtrlRegs.GPAMUX1.all = 0x00000000;  // All GPIO
    GpioCtrlRegs.GPADIR.all = 0x0000003C;   // GPIO2-5
    
    //STEPMOTOR CS	
	GpioCtrlRegs.GPAPUD.bit.GPIO25 = 0;   									// Enable pullup on GPIO27
    GpioDataRegs.GPASET.bit.GPIO25 = 1;   									// Load output latch
    GpioCtrlRegs.GPAMUX2.bit.GPIO25 = 0;  									// GPIO25 = GPIO
    GpioCtrlRegs.GPADIR.bit.GPIO25 = 1;   									// GPIO25 = output  
	GpioDataRegs.GPACLEAR.bit.GPIO25 = 1;

	//GPIO0-GPIO31输出低电平
    GpioDataRegs.GPADAT.all=0x00000000;
    EDIS;   
} 

//--------------------------------------------------------------------------------------------------------AUDIO
void I2CA_Init(void)
{
   // Initialize I2C
   I2caRegs.I2CSAR = 0x001A;		// Slave address - EEPROM control code

   #if (CPU_FRQ_150MHZ)             // Default - For 150MHz SYSCLKOUT
        I2caRegs.I2CPSC.all = 14;   // Prescaler - need 7-12 Mhz on module clk (150/15 = 10MHz)
   #endif
   #if (CPU_FRQ_100MHZ)             // For 100 MHz SYSCLKOUT
     I2caRegs.I2CPSC.all = 9;	    // Prescaler - need 7-12 Mhz on module clk (100/10 = 10MHz)
   #endif

   I2caRegs.I2CCLKL = 100;			// NOTE: must be non zero
   I2caRegs.I2CCLKH = 100;			// NOTE: must be non zero
   I2caRegs.I2CIER.all = 0x24;		// Enable SCD & ARDY interrupts

//   I2caRegs.I2CMDR.all = 0x0020;	// Take I2C out of reset
   I2caRegs.I2CMDR.all = 0x0420;	// Take I2C out of reset		//zq
   									// Stop I2C when suspended

   I2caRegs.I2CFFTX.all = 0x6000;	// Enable FIFO mode and TXFIFO
   I2caRegs.I2CFFRX.all = 0x2040;	// Enable RXFIFO, clear RXFFINT,

   return;
}

Uint16 AIC23Write(int Address,int Data)
{


   if (I2caRegs.I2CMDR.bit.STP == 1)
   {
      return I2C_STP_NOT_READY_ERROR;
   }

   // Setup slave address
   I2caRegs.I2CSAR = 0x1A;

   // Check if bus busy
   if (I2caRegs.I2CSTR.bit.BB == 1)
   {
      return I2C_BUS_BUSY_ERROR;
   }

   // Setup number of bytes to send
   // MsgBuffer + Address
   I2caRegs.I2CCNT = 2;
   I2caRegs.I2CDXR = Address;
   I2caRegs.I2CDXR = Data;
   // Send start as master transmitter
   I2caRegs.I2CMDR.all = 0x6E20;
   return I2C_SUCCESS;
}

void Audio_Delay(int time)
{
 int i,j,k=0;
 for(i=0;i<time;i++)
  for(j=0;j<1024;j++)
   k++;
}

interrupt void  ISRMcbspSend(void)
{
      int temp1,temp2;
      temp1=McbspaRegs.DRR1.all;
	  temp2=McbspaRegs.DRR2.all;       
  McbspaRegs.DXR1.all = temp1;        //放音
	 McbspaRegs.DXR2.all = temp2;
    PieCtrlRegs.PIEACK.all = 0x0020;    
}

//--------------------------------------------------------------------------------------------------------NET
/*void Load_Net_Parameters(void)
{
	Gateway_IP[0] = 192;
	Gateway_IP[1] = 168;
	Gateway_IP[2] = 1;
	Gateway_IP[3] = 1;

	Sub_Mask[0]=255;
	Sub_Mask[1]=255;
	Sub_Mask[2]=255;
	Sub_Mask[3]=0;

	Phy_Addr[0]=0x0c;
	Phy_Addr[1]=0x29;
	Phy_Addr[2]=0xab;
	Phy_Addr[3]=0x7c;
	Phy_Addr[4]=0x00;
	Phy_Addr[5]=0x01;

	IP_Addr[0]=192;
	IP_Addr[1]=168;
	IP_Addr[2]=1;
	IP_Addr[3]=99;

	S0_Port[0] = 0x13;
	S0_Port[1] = 0x88;

	S0_Mode=UDP_MODE;
}

void W5500_Socket_Set(void)
{
	if(S0_State==0)
	{
		if(Socket_UDP(0)==TRUE)
		{
			S0_State=S_INIT|S_CONN;
		}
		else
		{
			S0_State=0;
		}
	}
}

void W5500_Initialization(void)
{
	W5500_Init();
	Detect_Gateway();
	Socket_Init(0);	
	W5500_Socket_Set();
}

void W5500_Config(void)
{
	Load_Net_Parameters();
	W5500_Initialization();
}

interrupt void	W5500_isr(void)
{
	PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;
	W5500_Interrupt=1;
}

void NET_SPI_Init(void)
{    
	SpiaRegs.SPICCR.all =0x0007;// SPI软件复位, 极性位为0（上降沿发送数据）, 每次移进和移出8位字长度；禁止SPI内部回送（LOOKBACK）功能；
	SpiaRegs.SPICTL.all =0x0006; // 使能主机模式，正常相位，使能主机发送，禁止接收,溢出中断，禁止SPI中断；                                 
	SpiaRegs.SPIBRR =0x003F;	//SPI波特率=25M/32	=195.3KHZ；		
	SpiaRegs.SPICCR.bit.CLKPOLARITY = 0;//设置SPI移位时钟极性
	SpiaRegs.SPICTL.bit.CLK_PHASE=1;					
    SpiaRegs.SPICCR.bit.SPISWRESET=1; 
    SpiaRegs.SPIPRI.bit.FREE = 1;  // 自由运行     
}*/
//--------------------------------------------------------------------------------MAIN----------------------------------------------------------
void main(void)
{
	Uint16 i,j;
   Uint32 Sum=0;
   Uint32 Vin;
   Uint16 s1=1,s2=2,s3=3,s4=4;
   Uint16 tmp=0;
    Uint16 ReceivedChar;
    char *msg;

   InitSysCtrl();
   DINT;
   InitPieCtrl();
   IER = 0x0000;
   IFR = 0x0000;
   InitPieVectTable();
   InitSciGpio();
   scia_fifo_init();	   // Initialize the SCI FIFO
   scia_echoback_init();  // Initalize SCI for echoback
//------------------------------------------------------------------------------------------------SCI A&B ST	
    scib_fifo_init();	   // Initialize the SCI FIFO
    scib_echoback_init();  // Initalize SCI for echoback
    msg = "\r\nSelftest Start! \n\0";
    scia_msg(msg);
    msg = "\r\n-----------------------------------COMB Test----------------------------------- \0";
    scia_msg(msg);
    
    msg = "\r\nIf you see the message, press any key \0";
    scib_msg(msg);
    // Wait for inc character
    while(ScibRegs.SCIFFRX.bit.RXFFST !=1) { } 
    ReceivedChar = ScibRegs.SCIRXBUF.all;
    if(ReceivedChar>0)
	{
		msg = "\r\nCOMB Test-----OK! \n\0";
    	scia_msg(msg);
		SCIBOK=1;
	}
    else SCIBOK=0;
//------------------------------------------------------------------------------------------------RS485 ST	
    ReceivedChar=0;
    scic_echoback_init();
    msg = "\r\n-----------------------------------RS485 Test----------------------------------- \0";
    scia_msg(msg);
    msg = "\r\nIf you see the message, press any key \0";
    scic_msg(msg);
    // Wait for inc character
    while(ScicRegs.SCIFFRX.bit.RXFFST !=1) { } 
    ReceivedChar = ScicRegs.SCIRXBUF.all;
    if(ReceivedChar>0)
	{
		msg = "\r\nRS485 Test-----OK! \n\0";
    	scia_msg(msg);
		RS485OK=1;
	}
    else RS485OK=0;   
//------------------------------------------------------------------------------------------------SEG&AD ST
	msg = "\r\n-----------------------------------SegLED&AD Test----------------------------------- \0";
    scia_msg(msg);
    msg = "\r\nIf the value is right,press any key \0";
    scia_msg(msg);
    ReceivedChar=0;
   EALLOW;
   SysCtrlRegs.HISPCP.all = ADC_MODCLK;	// HSPCLK = SYSCLKOUT/（2*ADC_MODCLK）=15MHZ
   EDIS;
   InitSegCS();
   InitSpiaGpio();   
   InitAdc();
   spi_fifo_init(); 
   spi_init();
   AdcRegs.ADCTRL1.bit.ACQ_PS = ADC_SHCLK;//设置采样窗口时间：（15+1）*ADCCLK
   AdcRegs.ADCTRL3.bit.ADCCLKPS = ADC_CKPS;//ADC内核时钟分频：HSPCLK/2=6.25MHZ
   AdcRegs.ADCTRL1.bit.SEQ_CASC = 1;        // 1选择级联模式
   AdcRegs.ADCCHSELSEQ1.bit.CONV00 = 0x0;  //通道选择ADCAIN0
   AdcRegs.ADCTRL1.bit.CONT_RUN = 1;       // 设置为连续运行
   AdcRegs.ADCTRL2.all = 0x2000;
   for(;;)
   {
     Sum=0;
     for (i=0; i<BUF_SIZE; i++)
     {
     	SampleTable[i] = 0;
     }
     for (i=0; i<AVG; i++)
     {
        while (AdcRegs.ADCST.bit.INT_SEQ1== 0) {} // 等待中断
        AdcRegs.ADCST.bit.INT_SEQ1_CLR = 1;
        SampleTable[i] =((AdcRegs.ADCRESULT0>>4) );
     }
	 for (i=0;i<AVG;i++)
	 {
      Sum+=SampleTable[i];
	  Sum=Sum/2;
	 }
	 Vin=Sum*3*1000/4096;
	 s1=Vin/1000;
	 s2=Vin%1000/100;
	 s3=Vin%1000%100/10;
	 s4=Vin%1000%100%10;
	 ShowChar(s1,s2,s3,s4);
	if(SciaRegs.SCIFFRX.bit.RXFFST !=0)
	{
    	SciaRegs.SCIFFRX.bit.RXFIFORESET = 0;
    	SciaRegs.SCIFFRX.bit.RXFIFORESET = 1;
    	ReceivedChar = SciaRegs.SCIRXBUF.all;
	}
    if(ReceivedChar>0)
	{
		msg = "\r\nSEG&AD Test-----OK! \n\0";
    	scia_msg(msg);
		SEGADOK=1;
		break;
	}
	else SEGADOK=0;
	loopdelay();
   }
//------------------------------------------------------------------------------------------------DAC ST
	msg = "\r\n--------------------------------------DAC Test----------------------------------- \0";
    scia_msg(msg);
    msg = "\r\nIf the value A:0.4 B:0.8 C:1.2 D:1.6 is right, press any key \0";
    scia_msg(msg);
    ReceivedChar=0;
    EALLOW;
	GpioCtrlRegs.GPBMUX2.bit.GPIO49 = 0;
	GpioCtrlRegs.GPBDIR.bit.GPIO49 = 1;
	GpioCtrlRegs.GPBPUD.bit.GPIO49 = 0; 
	EDIS;
    SetLOAD;
    WriteDAC(0,0,31);	//0.4V
	WriteDAC(1,0,62);	//0.8V
	WriteDAC(2,0,93);	//1.2V
	WriteDAC(3,0,124);	//1.6V   
    while(SciaRegs.SCIFFRX.bit.RXFFST !=1) { } // Wait for inc character
    ReceivedChar = SciaRegs.SCIRXBUF.all;
    if(ReceivedChar>0)
	{
		msg = "\r\nDAC Test-----OK! \n\0";
    	scia_msg(msg);
		DACOK=1;
	}
    else DACOK=0;
//------------------------------------------------------------------------------------------------RTC&LCD ST
	msg = "\r\n-----------------------------------RTC&LCD Test----------------------------------- \0";
    scia_msg(msg);
    msg = "\r\nCheck the time diapalyed in LCD, press any key \0";
    scia_msg(msg);
    ReceivedChar=0;
    Eerom_Gpio_Init();
    Init_Port();
    LCD_init();
    Init8563();
    for(;;)
    {
    	GetTime();
    	LCD_write_command(0x90);
		tmp=TAB_T[2];
		tmp>>=4;
		tmp+=0x30;
		LCD_write_data(tmp);
		tmp=TAB_T[2];
		tmp&=0x000F;
		tmp+=0x30;
		LCD_write_data(tmp);
		LCD_write_data('-');
		tmp=TAB_T[1];
		tmp>>=4;
		tmp+=0x30;
		LCD_write_data(tmp);
		tmp=TAB_T[1];
		tmp&=0x000F;
		tmp+=0x30;
		LCD_write_data(tmp);
		LCD_write_data('-');
		tmp=TAB_T[0];
		tmp>>=4;
		tmp+=0x30;
		LCD_write_data(tmp);
		tmp=TAB_T[0];
		tmp&=0x000F;
		tmp+=0x30;
		LCD_write_data(tmp);
    	if(SciaRegs.SCIFFRX.bit.RXFFST !=0)
		{
    		SciaRegs.SCIFFRX.bit.RXFIFORESET = 0;
    		SciaRegs.SCIFFRX.bit.RXFIFORESET = 1;
    		ReceivedChar = SciaRegs.SCIRXBUF.all;
		}
    	if(ReceivedChar>0)
		{
			msg = "\r\nRTC&LCD Test-----OK! \n\0";
    		scia_msg(msg);
			RTCLCDOK=1;
			break;
		}
		else RTCLCDOK=0;
		loopdelay();
    }
	GpioDataRegs.GPADAT.bit.GPIO24 = 1;  //cs=1
//------------------------------------------------------------------------------------------------EEPROM ST	
	Uint16 Errcnt=0;
	Eerom_Gpio_Init();
	msg = "\r\n-----------------------------------EEPROM Test----------------------------------- \0";
    scia_msg(msg);
	for(i = 0;i<8;i++)
    {    		
		writebyte(i,TranBuf[i]);					//写Eeprom
		delay(50000);
		RecvBuf[i] = readbyte(i);					//读Eeprom
		delay(50000);
    }
	for(i = 0;i<8;i++)
	{
		if(TranBuf[i]!=RecvBuf[i])
		{
			Errcnt++;
		}
	}
    if(Errcnt==0)
    {
		msg = "\r\nEEPROM Test-----OK! \n\0";
    	scia_msg(msg);
    	EEROK=1;
    }
    else EEROK=0;
//------------------------------------------------------------------------------------------------BUZZ ST	
	msg = "\r\n-----------------------------------BUZZ Test----------------------------------- \0";
    scia_msg(msg);
    msg = "\r\nIf you can hear the song from buzz, press any key \0";
    scia_msg(msg);
    ReceivedChar=0;
    Buzz_Gpio_Init();
    EALLOW;  // This is needed to write to EALLOW protected registers
   	PieVectTable.TINT0 = &cpu_timer0_isr;
   	EDIS;    // This is needed to disable write to EALLOW protected registers
    InitCpuTimers();   // For this example, only initialize the Cpu Timers
   	ConfigCpuTimer(&CpuTimer0, 150, 50);
   	IER |= M_INT1;
   	PieCtrlRegs.PIEIER1.bit.INTx7 = 1;
   	EINT;   // Enable Global interrupt INTM
   	ERTM;   // Enable Global realtime interrupt DBGM
   	Uint16 addr=0;
    for(;;)
    {
		if(Musi[Song[addr]]==0xFF)									
		{
			addr=0;															//音乐播放结束
		}
		else
		{
			StopCpuTimer0();												//停止计数
			DISABLE_TIMER1_INT;												//不使能定时中断
			ConfigCpuTimer(&CpuTimer0, 150, Musi[Song[addr]+8]);			//设置定时时间
			StartCpuTimer0();												//重启定时器
			ENABLE_TIMER1_INT;												//使能定时中断
			Buzz_Delay(DT[addr]);												//音乐节拍延时
			StopCpuTimer0();												//停止计数
			DISABLE_TIMER1_INT;												//不使能定时中断
			BUZZ_OFF;														//关闭蜂鸣器
			Buzz_Delay(8);														//音乐停顿
			addr++;
		}
		if(SciaRegs.SCIFFRX.bit.RXFFST !=0)
		{
    		SciaRegs.SCIFFRX.bit.RXFIFORESET = 0;
    		SciaRegs.SCIFFRX.bit.RXFIFORESET = 1;
    		ReceivedChar = SciaRegs.SCIRXBUF.all;
		}
    	if(ReceivedChar>0)
		{
			msg = "\r\nBUZZ Test-----OK! \n\0";
    		scia_msg(msg);
			BUZZOK=1;
			break;
		}
		else BUZZOK=0;
    }
//------------------------------------------------------------------------------------------------PWM ST	
	msg = "\r\n-----------------------------------PWM Test----------------------------------- \0";
    scia_msg(msg);
    msg = "\r\nIf the freq. is 150kHz, press any key \0";
    scia_msg(msg);
    ReceivedChar=0;
    InitEPwm1Gpio();
    InitEPwm2Gpio();
    EALLOW;
   	SysCtrlRegs.PCLKCR0.bit.TBCLKSYNC = 0;
   	EDIS;
   	HRPWM1_Config(5000);
   	HRPWM2_Config(1000);
   	EALLOW;
    SysCtrlRegs.PCLKCR0.bit.TBCLKSYNC = 1;
    EDIS;
    EALLOW;
    GpioCtrlRegs.GPAPUD.bit.GPIO26 = 0;   									// Enable pullup on GPIO27
    GpioDataRegs.GPASET.bit.GPIO26 = 1;   									// Load output latch
    GpioCtrlRegs.GPAMUX2.bit.GPIO26 = 0;  									// GPIO27 = GPIO
    GpioCtrlRegs.GPADIR.bit.GPIO26 = 1;   									// GPIO27 = output  
	GpioDataRegs.GPACLEAR.bit.GPIO26 = 1;
	EDIS;
    while(SciaRegs.SCIFFRX.bit.RXFFST !=1) { } 
    ReceivedChar = SciaRegs.SCIRXBUF.all;
    if(ReceivedChar>0)
	{
		msg = "\r\nPWM Test-----OK! \n\0";
    	scia_msg(msg);
		PWMOK=1;
	}
    else PWMOK=0;
    EALLOW;
   	SysCtrlRegs.PCLKCR0.bit.TBCLKSYNC = 0;
   	EDIS;
//------------------------------------------------------------------------------------------------CAN ST	
	msg = "\r\n-----------------------------------CAN Test----------------------------------- \0";
    scia_msg(msg);
	InitECanGpio();
    EALLOW;
    ECanaShadow.CANTIOC.all = ECanaRegs.CANTIOC.all;
    ECanaShadow.CANTIOC.bit.TXFUNC = 1;
    ECanaRegs.CANTIOC.all = ECanaShadow.CANTIOC.all;

    ECanaShadow.CANRIOC.all = ECanaRegs.CANRIOC.all;
    ECanaShadow.CANRIOC.bit.RXFUNC = 1;
    ECanaRegs.CANRIOC.all = ECanaShadow.CANRIOC.all;
    EDIS;

    ECanaRegs.CANME.all = 0;

    ECanaMboxes.MBOX0.MSGID.all = 0x9555AAA0; 
    ECanaMboxes.MBOX1.MSGID.all = 0x9555AAA1; 
    ECanaMboxes.MBOX2.MSGID.all = 0x9555AAA2; 
    ECanaMboxes.MBOX3.MSGID.all = 0x9555AAA3; 
    ECanaMboxes.MBOX4.MSGID.all = 0x9555AAA4; 
    ECanaMboxes.MBOX5.MSGID.all = 0x9555AAA5; 
    ECanaMboxes.MBOX6.MSGID.all = 0x9555AAA6; 
    ECanaMboxes.MBOX7.MSGID.all = 0x9555AAA7; 
    ECanaMboxes.MBOX8.MSGID.all = 0x9555AAA8; 
    ECanaMboxes.MBOX9.MSGID.all = 0x9555AAA9; 
    ECanaMboxes.MBOX10.MSGID.all = 0x9555AAAA; 
    ECanaMboxes.MBOX11.MSGID.all = 0x9555AAAB; 
    ECanaMboxes.MBOX12.MSGID.all = 0x9555AAAC; 
    ECanaMboxes.MBOX13.MSGID.all = 0x9555AAAD; 
    ECanaMboxes.MBOX14.MSGID.all = 0x9555AAAE; 
    ECanaMboxes.MBOX15.MSGID.all = 0x9555AAAF; 
    
    ECanaMboxes.MBOX16.MSGID.all = 0x9555AAA0; 
    ECanaMboxes.MBOX17.MSGID.all = 0x9555AAA1; 
    ECanaMboxes.MBOX18.MSGID.all = 0x9555AAA2; 
    ECanaMboxes.MBOX19.MSGID.all = 0x9555AAA3; 
    ECanaMboxes.MBOX20.MSGID.all = 0x9555AAA4; 
    ECanaMboxes.MBOX21.MSGID.all = 0x9555AAA5; 
    ECanaMboxes.MBOX22.MSGID.all = 0x9555AAA6; 
    ECanaMboxes.MBOX23.MSGID.all = 0x9555AAA7; 
    ECanaMboxes.MBOX24.MSGID.all = 0x9555AAA8; 
    ECanaMboxes.MBOX25.MSGID.all = 0x9555AAA9; 
    ECanaMboxes.MBOX26.MSGID.all = 0x9555AAAA; 
    ECanaMboxes.MBOX27.MSGID.all = 0x9555AAAB; 
    ECanaMboxes.MBOX28.MSGID.all = 0x9555AAAC; 
    ECanaMboxes.MBOX29.MSGID.all = 0x9555AAAD; 
    ECanaMboxes.MBOX30.MSGID.all = 0x9555AAAE; 
    ECanaMboxes.MBOX31.MSGID.all = 0x9555AAAF; 

    ECanaRegs.CANMD.all = 0xFFFF0000; 
    
    ECanaRegs.CANME.all = 0xFFFFFFFF;

    ECanaMboxes.MBOX0.MSGCTRL.bit.DLC = 8;
    ECanaMboxes.MBOX1.MSGCTRL.bit.DLC = 8;
    ECanaMboxes.MBOX2.MSGCTRL.bit.DLC = 8;
    ECanaMboxes.MBOX3.MSGCTRL.bit.DLC = 8;
    ECanaMboxes.MBOX4.MSGCTRL.bit.DLC = 8;
    ECanaMboxes.MBOX5.MSGCTRL.bit.DLC = 8;
    ECanaMboxes.MBOX6.MSGCTRL.bit.DLC = 8;
    ECanaMboxes.MBOX7.MSGCTRL.bit.DLC = 8;
    ECanaMboxes.MBOX8.MSGCTRL.bit.DLC = 8;
    ECanaMboxes.MBOX9.MSGCTRL.bit.DLC = 8;
    ECanaMboxes.MBOX10.MSGCTRL.bit.DLC = 8;
    ECanaMboxes.MBOX11.MSGCTRL.bit.DLC = 8;
    ECanaMboxes.MBOX12.MSGCTRL.bit.DLC = 8;
    ECanaMboxes.MBOX13.MSGCTRL.bit.DLC = 8;
    ECanaMboxes.MBOX14.MSGCTRL.bit.DLC = 8;
    ECanaMboxes.MBOX15.MSGCTRL.bit.DLC = 8;
     
    ECanaMboxes.MBOX0.MSGCTRL.bit.RTR = 0;      
    ECanaMboxes.MBOX1.MSGCTRL.bit.RTR = 0;  
    ECanaMboxes.MBOX2.MSGCTRL.bit.RTR = 0;  
    ECanaMboxes.MBOX3.MSGCTRL.bit.RTR = 0;
    ECanaMboxes.MBOX4.MSGCTRL.bit.RTR = 0;
    ECanaMboxes.MBOX5.MSGCTRL.bit.RTR = 0;
    ECanaMboxes.MBOX6.MSGCTRL.bit.RTR = 0;
    ECanaMboxes.MBOX7.MSGCTRL.bit.RTR = 0;
    ECanaMboxes.MBOX8.MSGCTRL.bit.RTR = 0;
    ECanaMboxes.MBOX9.MSGCTRL.bit.RTR = 0;
    ECanaMboxes.MBOX10.MSGCTRL.bit.RTR = 0;
    ECanaMboxes.MBOX11.MSGCTRL.bit.RTR = 0;
    ECanaMboxes.MBOX12.MSGCTRL.bit.RTR = 0;
    ECanaMboxes.MBOX13.MSGCTRL.bit.RTR = 0;
    ECanaMboxes.MBOX14.MSGCTRL.bit.RTR = 0;
    ECanaMboxes.MBOX15.MSGCTRL.bit.RTR = 0;
    
    ECanaMboxes.MBOX0.MDL.all = 0x9555AAA0;
    ECanaMboxes.MBOX0.MDH.all = 0x89ABCDEF;

    ECanaMboxes.MBOX1.MDL.all = 0x9555AAA1;
    ECanaMboxes.MBOX1.MDH.all = 0x89ABCDEF;
   
    ECanaMboxes.MBOX2.MDL.all = 0x9555AAA2;
    ECanaMboxes.MBOX2.MDH.all = 0x89ABCDEF;
 
    ECanaMboxes.MBOX3.MDL.all = 0x9555AAA3;
    ECanaMboxes.MBOX3.MDH.all = 0x89ABCDEF;
 
    ECanaMboxes.MBOX4.MDL.all = 0x9555AAA4;
    ECanaMboxes.MBOX4.MDH.all = 0x89ABCDEF;
 
    ECanaMboxes.MBOX5.MDL.all = 0x9555AAA5;
    ECanaMboxes.MBOX5.MDH.all = 0x89ABCDEF;
 
    ECanaMboxes.MBOX6.MDL.all = 0x9555AAA6;
    ECanaMboxes.MBOX6.MDH.all = 0x89ABCDEF;
 
    ECanaMboxes.MBOX7.MDL.all = 0x9555AAA7;
    ECanaMboxes.MBOX7.MDH.all = 0x89ABCDEF;
 
    ECanaMboxes.MBOX8.MDL.all = 0x9555AAA8;
    ECanaMboxes.MBOX8.MDH.all = 0x89ABCDEF;
 
    ECanaMboxes.MBOX9.MDL.all = 0x9555AAA9;
    ECanaMboxes.MBOX9.MDH.all = 0x89ABCDEF;
 
    ECanaMboxes.MBOX10.MDL.all = 0x9555AAAA;
    ECanaMboxes.MBOX10.MDH.all = 0x89ABCDEF;
 
    ECanaMboxes.MBOX11.MDL.all = 0x9555AAAB;
    ECanaMboxes.MBOX11.MDH.all = 0x89ABCDEF;
 
    ECanaMboxes.MBOX12.MDL.all = 0x9555AAAC;
    ECanaMboxes.MBOX12.MDH.all = 0x89ABCDEF;
 
    ECanaMboxes.MBOX13.MDL.all = 0x9555AAAD;
    ECanaMboxes.MBOX13.MDH.all = 0x89ABCDEF;
 
    ECanaMboxes.MBOX14.MDL.all = 0x9555AAAE;
    ECanaMboxes.MBOX14.MDH.all = 0x89ABCDEF;
 
    ECanaMboxes.MBOX15.MDL.all = 0x9555AAAF;
    ECanaMboxes.MBOX15.MDH.all = 0x89ABCDEF;

    EALLOW;
    ECanaRegs.CANMIM.all = 0xFFFFFFFF;
    ECanaShadow.CANMC.all = ECanaRegs.CANMC.all;
    ECanaShadow.CANMC.bit.CCR = 1;            
    ECanaRegs.CANMC.all = ECanaShadow.CANMC.all;
    EDIS;
    do 
    {
      ECanaShadow.CANES.all = ECanaRegs.CANES.all;
    } while(ECanaShadow.CANES.bit.CCE != 1 ); 
    EALLOW;
    ECanaShadow.CANBTC.all = ECanaRegs.CANBTC.all;

    ECanaShadow.CANBTC.bit.BRPREG = 9;    // (BRPREG + 1) = 10 feeds a 15 MHz CAN clock
    ECanaShadow.CANBTC.bit.TSEG2REG = 5 ; // to the CAN module. (150 / 10 = 15)
    ECanaShadow.CANBTC.bit.TSEG1REG = 7;  // Bit time = 15
    ECanaRegs.CANBTC.all = ECanaShadow.CANBTC.all;
    
    ECanaShadow.CANMC.all = ECanaRegs.CANMC.all;
    ECanaShadow.CANMC.bit.CCR = 0;            
    ECanaRegs.CANMC.all = ECanaShadow.CANMC.all;
    EDIS;
    do
    {
      ECanaShadow.CANES.all = ECanaRegs.CANES.all;
    } while(ECanaShadow.CANES.bit.CCE != 0 );
    EALLOW;
    ECanaShadow.CANMC.all = ECanaRegs.CANMC.all;
    ECanaShadow.CANMC.bit.STM = 1;    // Configure CAN for self-test mode  
    ECanaShadow.CANMC.bit.SCB = 1;    // eCAN mode (reqd to access 32 mailboxes)
    ECanaRegs.CANMC.all = ECanaShadow.CANMC.all;
    EDIS;
    ECanaRegs.CANTRS.all = 0x0000FFFF;  // Set TRS for all transmit mailboxes
    while(ECanaRegs.CANTA.all != 0x0000FFFF ) {}  // Wait for all TAn bits to be set..
    ECanaRegs.CANTA.all = 0x0000FFFF;   // Clear all TAn    
       
    for(i=0; i<16; i++)         // Read & check 16 mailboxes
    {
       mailbox_read(i);         // This func reads the indicated mailbox data
       mailbox_check(TestMbox1,TestMbox2,TestMbox3); // Checks the received data
    }
    if(CANErCnt == 0)
    {
    	msg = "\r\nCAN Test-----OK! \n\0";
    	scia_msg(msg);
		CANOK=1;
    }
    else CANOK=0;
//------------------------------------------------------------------------------------------------KEY&EXINT ST	
	msg = "\r\n------------------------------KEY&EXINT Test----------------------------------- \0";
    scia_msg(msg);
    msg = "\r\nPress K4&K5,check LED7&LED8, press any key \0";
    scia_msg(msg);
    ReceivedChar=0;
	EALLOW;	 
    PieVectTable.XINT1 = &xint1_isr;
    PieVectTable.XINT2 = &xint2_isr;
    EDIS;   
    Xint1Count = 0; // 计数外部中断1（XINT1）
    Xint2Count = 0; // 计数外部中断2（XINT2） 
    PieCtrlRegs.PIECTRL.bit.ENPIE = 1;          // 使能外设中断扩展PIE模块
    PieCtrlRegs.PIEIER1.bit.INTx4 = 1;          // 使能PIE组1的INT4
    PieCtrlRegs.PIEIER1.bit.INTx5 = 1;          // 使能PIE组1的INT5   
    IER |= M_INT1;                              // 使能CPU中断1（INT1）
    EINT;
    
    EALLOW;
   GpioCtrlRegs.GPAMUX1.bit.GPIO14 = 0;         // 选择为通用I/O口
   GpioCtrlRegs.GPADIR.bit.GPIO14 = 0;          // 方向定义为输入
   GpioCtrlRegs.GPAQSEL1.bit.GPIO14 = 0;        // 外部中断1（XINT1）与系统时钟SYSCLKOUT同步

   GpioCtrlRegs.GPAMUX1.bit.GPIO15 = 0;         // 选择为通用I/O口
   GpioCtrlRegs.GPADIR.bit.GPIO15 = 0;          // 方向定义为输入
   GpioCtrlRegs.GPAQSEL1.bit.GPIO15 = 2;        // 外部中断2（XINT2）输入限定6个采样窗口
   GpioCtrlRegs.GPACTRL.bit.QUALPRD1 = 0xFF;   // 每个采样窗口的周期为510*SYSCLKOUT 

   GpioCtrlRegs.GPAMUX1.bit.GPIO2 = 0;
   GpioCtrlRegs.GPADIR.bit.GPIO2 = 1;
   GpioCtrlRegs.GPAMUX1.bit.GPIO3 = 0;
   GpioCtrlRegs.GPADIR.bit.GPIO3 = 1;
   GpioCtrlRegs.GPAMUX1.bit.GPIO4 = 0;
   GpioCtrlRegs.GPADIR.bit.GPIO4 = 1;
   GpioCtrlRegs.GPAMUX1.bit.GPIO5 = 0;
   GpioCtrlRegs.GPADIR.bit.GPIO5 = 1;
   GpioCtrlRegs.GPAMUX1.bit.GPIO6 = 0;
   GpioCtrlRegs.GPADIR.bit.GPIO6 = 1;
   GpioCtrlRegs.GPAMUX1.bit.GPIO7 = 0;
   GpioCtrlRegs.GPADIR.bit.GPIO7 = 1;
   GpioCtrlRegs.GPAMUX1.bit.GPIO8 = 0;
   GpioCtrlRegs.GPADIR.bit.GPIO8 = 1;
   GpioCtrlRegs.GPAMUX1.bit.GPIO9 = 0;
   GpioCtrlRegs.GPADIR.bit.GPIO9 = 1;
   GpioDataRegs.GPADAT.all=0x000003FC;
   
   //LED CS	
	GpioCtrlRegs.GPAPUD.bit.GPIO27 = 0;   									// Enable pullup on GPIO27
    GpioDataRegs.GPASET.bit.GPIO27 = 1;   									// Load output latch
    GpioCtrlRegs.GPAMUX2.bit.GPIO27 = 0;  									// GPIO27 = GPIO
    GpioCtrlRegs.GPADIR.bit.GPIO27 = 1;   									// GPIO27 = output  
	GpioDataRegs.GPACLEAR.bit.GPIO27 = 1;      //LED cs=0
	
   EDIS;
   
   EALLOW;
   GpioIntRegs.GPIOXINT1SEL.bit.GPIOSEL = 0x0E;   // XINT1是GPIO14
   GpioIntRegs.GPIOXINT2SEL.bit.GPIOSEL = 0x0F;   // XINT2是GPIO15
   EDIS;

   XIntruptRegs.XINT1CR.bit.POLARITY = 0;      // 下降沿触发中断
   XIntruptRegs.XINT2CR.bit.POLARITY = 0;      // 下降沿触发中断
   
   XIntruptRegs.XINT1CR.bit.ENABLE = 1;        // 使能XINT1
   XIntruptRegs.XINT2CR.bit.ENABLE = 1;        // 使能XINT2
   while(SciaRegs.SCIFFRX.bit.RXFFST !=1) { } 
    ReceivedChar = SciaRegs.SCIRXBUF.all;
    if(ReceivedChar>0)
	{
		msg = "\r\nKEY&EXINT Test-----OK! \n\0";
    	scia_msg(msg);
		KEYINTOK=1;
	}
    else KEYINTOK=0;
    GpioDataRegs.GPASET.bit.GPIO27 = 1;

//------------------------------------------------------------------------------------------------DCMOT ST	
	msg = "\r\n--------------------------------DCMOT Test----------------------------------- \0";
    scia_msg(msg);
    msg = "\r\nCheck DC Motor, press any key  \0";
    scia_msg(msg);
    ReceivedChar=0;
    InitEPwm1Gpio();
    EALLOW;
    GpioCtrlRegs.GPAPUD.bit.GPIO26 = 0;   									// Enable pullup on GPIO27
    GpioDataRegs.GPASET.bit.GPIO26 = 1;   									// Load output latch
    GpioCtrlRegs.GPAMUX2.bit.GPIO26 = 0;  									// GPIO27 = GPIO
    GpioCtrlRegs.GPADIR.bit.GPIO26 = 1;   									// GPIO27 = output  
	GpioDataRegs.GPACLEAR.bit.GPIO26 = 1;
	EDIS;
	EALLOW;  // This is needed to write to EALLOW protected registers
    PieVectTable.EPWM1_INT = &epwm1_isr;
    EDIS;
	 
   EALLOW;
   SysCtrlRegs.PCLKCR0.bit.TBCLKSYNC = 0;
   EDIS;

   InitEPwm1Example();

   EALLOW;
   SysCtrlRegs.PCLKCR0.bit.TBCLKSYNC = 1;
   EDIS;
   
   IER |= M_INT3;

   PieCtrlRegs.PIEIER3.bit.INTx1 = 1;

   EINT;   // Enable Global interrupt INTM
   //ERTM;   // Enable Global realtime interrupt DBGM
   while(SciaRegs.SCIFFRX.bit.RXFFST !=1) { } 
    ReceivedChar = SciaRegs.SCIRXBUF.all;
    if(ReceivedChar>0)
	{
		msg = "\r\nDCMOT Test-----OK! \n\0";
    	scia_msg(msg);
		DCMOK=1;
	}
    else DCMOK=0;
   
   GpioDataRegs.GPASET.bit.GPIO27 = 1;
   
//------------------------------------------------------------------------------------------------STPMOT ST	
	msg = "\r\n--------------------------------STPMOT Test----------------------------------- \0";
    scia_msg(msg);
    ReceivedChar=0;
    Gpio_select();
    DINT;
    //CW
    j=256; //改变这个值可以控制转动周数。
    while(j--)
    {
      for(i=0;i<4;i++)
      {
       GpioDataRegs.GPADAT.all=Step_table[i]; //GPIO2-GPIO5依次输出高电平
       delay(20000);

      }
    }
    //CCW
	j=256;
	GpioDataRegs.GPADAT.all=0x0000;
	 while(j--)
   {
      for(i=0;i<4;i++)
      {
       GpioDataRegs.GPADAT.all=Step_table1[i]; //GPIO2-GPIO5依次输出高电平
       delay(20000);

      }
    }
    GpioDataRegs.GPASET.bit.GPIO25 = 1;
    msg = "\r\nCheck STP Motor, press any key  \0";
    scia_msg(msg);
    while(SciaRegs.SCIFFRX.bit.RXFFST !=1) { } 
    ReceivedChar = SciaRegs.SCIRXBUF.all;
    if(ReceivedChar>0)
	{
		msg = "\r\nSPTMOT Test-----OK! \n\0";
    	scia_msg(msg);
		STPMOK=1;
	}
    else STPMOK=0;

//------------------------------------------------------------------------------------------------AUDIO ST	
	msg = "\r\n--------------------------------AUDIO Test----------------------------------- \0";
    scia_msg(msg);
    msg = "\r\nIf you can hear what you said, press any key  \0";
    scia_msg(msg);
    InitMcbspaGpio();	//zq
   InitI2CGpio();
   DINT;
   InitPieCtrl();
   IER = 0x0000;
   IFR = 0x0000;
   InitPieVectTable();
   I2CA_Init();
	 AIC23Write(0x00,0x00);
	 Audio_Delay(100);
     AIC23Write(0x02,0x00);
     Audio_Delay(100);
	 AIC23Write(0x04,0x7f);
	 Audio_Delay(100);
     AIC23Write(0x06,0x7f);
	 Audio_Delay(100);
	 AIC23Write(0x08,0x14);
	 Audio_Delay(100);
     AIC23Write(0x0A,0x00);
	 Audio_Delay(100);
	 AIC23Write(0x0C,0x00);
	 Audio_Delay(100);
     AIC23Write(0x0E,0x43);
	 Audio_Delay(100);
	 AIC23Write(0x10,0x23);
	 Audio_Delay(100);
     AIC23Write(0x12,0x01);
	 Audio_Delay(100);		//AIC23Init	 
   InitMcbspa();          // Initalize the Mcbsp-A 
    EALLOW;	// This is needed to write to EALLOW protected registers
	PieVectTable.MRINTA = &ISRMcbspSend;
	EDIS;   // This is needed to disable write to EALLOW protected registers
    PieCtrlRegs.PIECTRL.bit.ENPIE = 1;   // Enable the PIE block
    PieCtrlRegs.PIEIER6.bit.INTx5=1;     // Enable PIE Group 6, INT 5
    IER |= M_INT6;                            // Enable CPU INT6
	EINT;   // Enable Global interrupt INTM
	ERTM;	// Enable Global realtime interrupt DBGM
	while(SciaRegs.SCIFFRX.bit.RXFFST !=1) { } 
    ReceivedChar = SciaRegs.SCIRXBUF.all;
    if(ReceivedChar>0)
	{
		msg = "\r\nAUDIO Test-----OK! \n\0";
    	scia_msg(msg);
		AUDOK=1;
	}
    else AUDOK=0;
    DINT;

//------------------------------------------------------------------------------------------------NET ST	
	/*msg = "\r\n--------------------------------NET Test----------------------------------- \0";
    scia_msg(msg);
    msg = "\r\nCheck the NET comm, press any key  \0";
    scia_msg(msg);
	InitSpiaGpio();  //开发板使用SPIA
	DINT;
   InitPieCtrl();
   IER = 0x0000;
   IFR = 0x0000;
   InitPieVectTable();
   EALLOW;	// 修改被保护的寄存器，修改前应添加EALLOW语句
   PieVectTable.XINT3 = &W5500_isr;
   EDIS;   // EDIS的意思是不允许修改被保护的寄存器
   
   EALLOW;		//CS
   GpioDataRegs.GPBSET.bit.GPIO51 = 1;         // 输出高电平
   GpioCtrlRegs.GPBMUX2.bit.GPIO51 = 0;        // 选择为通用I/O口
   GpioCtrlRegs.GPBDIR.bit.GPIO51 = 1;         // 方向定义为输出
   GpioDataRegs.GPBSET.bit.GPIO51=1;
   EDIS;
   
   EALLOW;		//INT
   GpioCtrlRegs.GPBMUX2.bit.GPIO52 = 0;         // 选择为通用I/O口
   GpioCtrlRegs.GPBDIR.bit.GPIO52 = 0;          // 方向定义为输入
   GpioCtrlRegs.GPBQSEL2.bit.GPIO52 = 2;        // 
   GpioCtrlRegs.GPBCTRL.bit.QUALPRD2 = 1;   // 每个采样窗口的周期为510*SYSCLKOUT 
   GpioCtrlRegs.GPBPUD.bit.GPIO52 = 0;
   EDIS;
   
   EALLOW;
   GpioIntRegs.GPIOXINT3SEL.bit.GPIOSEL = 52;   // XINT3是GPIO52
   EDIS;
   
   XIntruptRegs.XINT3CR.bit.POLARITY = 0;      // 下降沿触发中断
   XIntruptRegs.XINT3CR.bit.ENABLE = 1;        // 使能XINT3
   PieCtrlRegs.PIECTRL.bit.ENPIE = 1;          // 使能外设中断扩展PIE模块
   PieCtrlRegs.PIEIER12.bit.INTx1 = 1;          // 使能PIE组1的INT4  
   IER |= M_INT12;                              // 使能CPU中断1（INT1）
   EINT; 
   
   NET_SPI_Init();
   W5500_Config();
   for(;;)
   {
   		if(W5500_Interrupt)
		{
			W5500_Interrupt_Process();
		}
		if(SciaRegs.SCIFFRX.bit.RXFFST !=0)
		{
    		SciaRegs.SCIFFRX.bit.RXFIFORESET = 0;
    		SciaRegs.SCIFFRX.bit.RXFIFORESET = 1;
    		ReceivedChar = SciaRegs.SCIRXBUF.all;
		}
    	if(ReceivedChar>0)
		{
			msg = "\r\nNET Test-----OK! \n\0";
    		scia_msg(msg);
			NETOK=1;
			break;
		}
		else NETOK=0;
   }*/
//------------------------------------------------------------------------------------------------------
	msg = "\r\n--------------------------------SUMMERY----------------------------------- \0";
    scia_msg(msg);

}







//===========================================================================
// No more.
//===========================================================================

